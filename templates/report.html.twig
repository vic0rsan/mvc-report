{% extends "base.html.twig" %}

{% block title %}Redovisning{% endblock %}

{% block body %}
    <article>
        <header>
            <h1>Redovisning av kursmoment i mvc</h1>
        </header>
        <section>
            <h2 id="kmom01">Kmom01</h2>
            <p>Konceptet om objektorientering är ej något nytt för mig, har använt mig av det i tidigare dbwebb-kurser, både i Python och PHP från den förra mvc-kursen. Skillnaden mellan dessa språk ligger i syntaxen över hur en klass initieras och kan då utan svårigheter pendla mellan dessa språk.</p>
            <p>
                Än så länge har vi skapat klasser för controller som hanterar de olika sidorna utan någon konstruktor-metod, vilket är princip nästan som att programmera i den funktionell paradigmen. 
                Den enda objekt-specificerade syntaxen för utom klass-deklarationen var instansvariabeln $this som representerar en instans av en klass. När man skapar klasser börjar man med självaste deklarationen, sedan bör man skapa en konstruktor för att lagra attribut för varje enskild instans. Slutligen kan man skapa klass-metoder som arbetar direkt med objekten och dess värden. 
            </p>
            <p>
                För att lägga till en undersida i symfony börjar man med att skapa en controller-klass i Controller-mappen om det inte redan finns,  sedan lägger man till klass-metoder som representerar varje enskild route/sida. För att koppla klassmetoden till GET-förfrågan så lägger man till en kommentar ovanför med funktions-anrop till Route med sökvägen och dess namn. 
                I varje klass-metod bör man åtminstone returnera instansvariabeln med render-funktionen med inparametern för motsvarande twig-fil. Innehållet för samtliga sidor finns i de olika twig-filerna i templates-mappen. I mappen finns en base-twig som innehåller head för samtliga sidorna som innehåller bland annat navbaren, länk till CSS-filen samt uppsättning av karaktärer (UTF-8). Övriga twig-filer ärver base klassen och bygger vidare på body-sektionen. Övrigt innehållet utöver text som bilder och CSS finns tillgänglig public-mappen med varsin mapp. 
            </p>
            <p>
                Jag kikade snabbt över artikeln och alla dess underrubriker, fann sektionen för säkerhet intressant då det är viktigt att kunna rusta upp sina webbapplikationer för cyberattacker/intrång, vilket blir ännu viktigare i framtiden pga den växande digitaliseringen där olika komponenter i samhället är helt beroende av ett digitalt-system för att fungera. 
            </p>
            <p>
                I detta kursmoment har jag lärt mig grunderna för PHP-ramverket Symfony vilket täcker skapandet av Controller, undersidor i twig, samt dess fil-struktur. Dock inga nya kunskaper gällande objektorientering  än så länge då allt kändes bekant. 
            </p>

            <h2 id="kmom02">Kmom02</h2>
            <p>
                Arv inom objektorientering är när en klass ärver klassmetoder och attribut från en föräldrar klass. Ett exempel skulle kunna vara en bass klass för djur där man väljer att skapa en barnklass för attribut som gäller för hundar. Man bygger helt enkelt vidare på bass klassen med nya metoder och attribut som gäller för specifika ändamål utan att påverka självaste föräldrar klassen. 
                En kompositions relation inom objektorientering menar man en relation som ena klassen är beroende av för att skapa dessa egna objekt. 
                Ett exempel skulle kunna vara ett rum i huset där ett rum kan inte existera utan ett hus, men ett hus behöver inte inneha några rum för att existera. En interface inom PHP-sammanhang är ett sätt att definiera klass metoder utan att direkt implementation. Interface är mer ett sätt för att spediera metoder som bör förekomma för klassen. 
                Slutligen traits är ett sätt att underlätta/undvika multipla ärv av klasser, då PHP saknar stöd för detta samt är det en bättre vanna att inte skapa klasser med multipla ärv. Traits är en uppsättning av klassmetoder som en eller flera klasser kan används sig utav utan att förbinda ett parent-child förhållande.
            </p>
            <p>
            Jag började med att skapa det grundläggande klasserna; Card och Deck med godtyckliga attributvärden och klassmetoder. Sedan skapade jag en ny controller för samtliga card-klasser för att testa initiering av objekt för att se om det fungerar som tänkt. Nästa steg var att skapa routes och twig-templates enligt kravspecen. Jag valde här näst en metod för att representera de olika spelkorten där min lösning var ett skapa en CardGraphic klass bestående av unicode-karaktärer och ärver Card klassen. 
            CardGraphics returnera motsvarande värde genom dess rang och färg motsvarare en specifik nyckel för unicode-arrayen som den anroppar och returneras unicode-värdet. Slutligen vissas samtliga spelkort genom en for-loop där CardGraphic metoden "getCardRep" anroppas. 
            Jag känner mig nöjd än så länge. En förbättringsförslag skulle möjligtvis var att dela upp klassmetoder från Deck till CardHand som relaterar till draw-funktionerna. En annan förbättring skulle kunna vara dokumentering/kommentera koden för att underlätta läsligheten för andra och mig själv.
            </p>
            <p>
                Än så länge känns allt tydligt och klart med Symfony och MVC-konceptet. Jag har arbetat i liknande utvecklingsmiljöer sedan tidigare.
            </p>
            <p>
                Min TIL handlar om det introducerade PHP-koncepten som Interface och Traits som verkar var bra ersättningar för ärv-relationer, vilket kan komma till nytta när man vill använda en uppsättning metoder utan att skapa ett beroende/förhållande med en klass.
            </p>

            <h2 id="kmom03">Kmom03</h2>
            <p>
                Fördelen med att modellera ett projekt innan man börjar med implementationer är att man kan överföra tanker och idéer från huvudet till pappret vilket medför att man kan få en checklista att boka av genom utvecklingsstadiet, vilket medför en smidigare utvecklingsprocess. 
                För mig får jag även en form av validation om tankarna finns rakt framför mig i fysiskt form och kan då enklare bryta ned dem för att se om det håller i "verkligheten". En annan fördel med flödesdiagram och pseudokod skulle vara för att redovisa sina tankar inom ex ett utvecklingsteam där det är mer eller mindre obligatorisk då övriga skall kunna förstå samt validera dina tankar för projektet.
            </p>
            <p>
                Jag började med att skapa klassen för spel-kontroller. Nästa steg var att skapa de templates för sidorna enligt kravspecen. Sedan implementerad jag resterade metoder stegvist och validerade utmatningen av objekten med hjälp av "var_dump".  När jag kommit halvvägs genom projektet noterade jag att kontroller började bli en aning  massiv och beslutade då enligt uppmaningen från kravspecen att refaktoriserar koden med hjälp av en separat klass för spelet och dess metoder/funktionalitet. 
                I slutändan sparade jag minskade jag kontroller med ca 30 rader kod. För att få motsvarande poäng för samtliga spelkort modifierade jag Card-klassen med ett nytt instansattribut "point" och en get-metod i HandCard-klassen (representerar spelarnas kort i handen) för att summera spelarnas kortsumma för varje runda. Jag är överlag nöjd med mitt kortspel när det kommer till funktionaliteten. Däremot kan gränssnittet poleras då den är för stunden relativt simpel/primitiv då jag har inte lagt en större del kring stylingen.
            </p>
            <p>
                Jag har inte haft några svårigheter att komma igång med Symfony då ramverket skiljer sig inte speciellt mycket från övriga ramverk som jag har jobbat med. Tycker konceptet med kontroller och templates är tydliga.
            </p>
            <p>
                Min TIL är hur självaste utvecklingsprocessen för ett mindre projekt inom Symfony kan ske.
            </p>

            <h2 id="kmom04">Kmom04</h2>
            <p>
                Jag har tidigare jobbat med enhetstester i andra programmeringsspråk som Python och JavaScript och noterade inga speciella skillnader med att skriva tester i PHPUnit. När det kom till att testa model-klasserna för min mvc-report gick det bra och behövde endast göra minimala ändringar i koden för att få den mer testbar. Ex i Game21-klassen vill jag testa en metod som avgör vem som vinner beroende på vilka kort i handen motståndaren har. 
                Eftersom korten tilldelas slumpmässigt behöver jag på något sätt skapa en lösning där man kan definiera en korthand. I mitt fall valde jag att skapa nya setters för vardera spelare där man kan skapa en korthand med specifika kort. Ett annan sätt att lösa ovanstående problem skulle kunna vara att mocka random-funktionen i metoden som tilldelar kort.
            </p>
            <p>
                Tycker jag lyckades väl med kodtäckningen av modell-klasserna där jag fick en täckning på hela 100% för totalt 5st klasser.
            </p>
            <p>
                Jag upplevde min kod för grundklasserna att var mer eller mindre testbara. Det enda klassen jag blev tvungen att fixa till var klassen som redogör en omgång av kortspelet, mer specifikt för att testa de olika sätten ett spel kan avslutas. Då poäng för spelets motståndare sker på slumpen, blir det då svårt att skriva testfall där den ger olika värden för varje anrop. Min lösning var att skapa setter-metoder för att ange det önskvärda värdet som triggar igång en av utfallen för ett spelets summering.
            </p>
            <p>
                Jag valde att addera klass-metoder istället för att skriva om existerande kod då jag vill ej riskera att något går sönder vid refaktoriseringen. De metoder jag la till var klass-setters vilket jag anser vara "lätta" på resurserna och tar upp få kodrader, vilket gjorde att jag kunde implementera dem utan dåligt samvete.
            </p>
            <p>
                Testbar kod är definitivt något som jag ser som en god kodkaraktäristik då det underlättar utförandet vid teststadiet. Tester är i sin tur ett sätt att garantera en viss kvalité av funktionalitet för programmet och för att säkerställa att metoderna har ett önskvärd beteende.
            </p>
            <p>
                Min TIL för detta kmom var hur man kan generera ett dokument för kodkommentarer med phpdoc och en täckningsrapport via phpunit.
            </p>

            <h2 id="kmom05">Kmom05</h2>
            <p>
                Det gick bra att komma igång med Doctrine för Symfony. Guiden förklarade stegvist för hur komponenterna fungerar samt gav exempelkod som underlättade vid den ursprungliga implementationen. Mina tankar kring ORM och Symfony var hur väl dessa verktyg var implementerad för att samarbeta med varandra. Tex kan man smidigt auto-generera en databas tabell utan att skriva en enda sql-lina. En annan egenskap med ORM/Symfony var dess medföljda script för versionshanteringar av tabeller.
            </p>
            <p>
                Mitt gränssnitt för webbappen kännetecknas av en simpel design med färger av högkontrast. jag valde att grunda mitt färgtema utifrån användargränssnitt från skrivbordsmiljöer 80-90-talet då dessa har god kontrast samt rent utav smaksak. Självaste navigationen samt aktivering av funktioner för sidan (ex lägga till, radera eller redigera) görs via länkar som tar användaren till en separat sida med formulär.
            </p>
            <p>
                Det gick bra med att komma igång med CRUD inom ORM. Jag upplevde ingen större skillnad än en traditionell relationsdatabas mer än att samtliga funktioner och rader sker via klass-metoder och instanser. För att lägga till, uppdatera eller radera en rad i tabellen görs via ett "ManagerRegister"-objekt. För att ex addera eller uppdatera användes klassmetoden "persist" som talar om att ett objekt är på väg in i databasen, sedan anges objektets attributer med set. För att spara ned ändringarna gör man en anrop till "flush"-klassmetoden.  Helt enkelt skiljer sig ORM med att man jobbar mot objekt där traditionella databaser används SQL-stränger för att kommunicera.
            </p>
            <p>
                ORM är ett alternativt sätt att processers data från databas tabeller där istället för SQL används objekt för att representera olika tabellrader. En fördel med ORM är att man skapa egna funktioner som kommunicerar med databasen inom valfritt programmeringsspråk utan en enda rad SQL.
            </p>
            <p>
                Jag har lärt mig en ny databas koncept där man jobbar med objekt istället för SQL samt hur man använder denna teknik inom ett Symfony-projekt.
            </p>

            <h2 id="kmom06">Kmom06</h2>
            <p>
                Jag tycker PHPMetrics är ett bra verktyg även om det kunde vara överväldigade i början med alla dess mätvärden och hur man skall tolka dem. Det var en del enheter jag hade svårigheter över vad det ger uttryck för. Det jag gillade med PHPMetrics var några grafer, 
                bland annat klass kod komplexiteten som redovisades som en spiral cirklar i olika färger för graden av komplexiteten. Det fanns även en graf där man kunde se kopplingar för samtliga klasser, vilket gav en tydliga överblick över klassrelationerna. 
            </p>
            <p>
                Det gick bra att komma igång med Scrutinizer, det fungerade felfritt direkt efter kopplingen. Jag tycker Scrutinizer har ett tydligt och simpelt gränssnitt vid presentation av data.  Tycker Badges är ett bra sätt att presentera projektets kodkvalitet. 
                Det verkar smidigt att ha klickbara badges för att i detalj se det olika kvalitetsaspekterna för projektet i fråga. Efter den första kopplingen fick jag en kodtäckning på 19% som jag fick sedan upp till 46% efter tillagt tester för olika controllers. 
            </p>
            <p>
                Kodkvaliten enligt mig är en viktigt grund för att projekt skall vara underhållbar och prestera bra. En tydlig kod anser jag ger även projektet ett gott första intryck för utomstående utvecklare och en större chans till engagement vid tex ett OpenSource projekt vilket kan gynna projektet i längden om flera utvecklare bidrar till dess utveckling. 
                Badges behöver inte alltid garantera att projektet är välskriven då automatiserade verktyg som Scrutinizer bedömer projektet utifrån en algoritm och kan därefter ha svårigheter att bedöma projektets funktionalitet i sin helhet och kan då ge en felaktig bedömning. 
                Enligt mig så bör man granska koden manuellt och försöka att se koden för projektet som en utomstående då vissa implementationer som är självklart för sig själv är inte alltid det för andra. 
            </p>
            <p>
                Min TIL handlar om hur man kan jobba med automatiserade kodvalidatorer för att förbättra kvalitén för sitt projekt. Samt att det finns ett brett spektrum av aspekter som tillsammans bidrar till det huvudsakliga kodkvaliten för ett projekt.
            </p>

            <h2 id="kmom10">Kmom10</h2>
            <h3>Krav 1-3</h3>
            <h4>Innehåll och utseende</h4>
            <p>
                Jag valde att utföra alternativet "five card poker" som min inriktning för slutprojekt då det ansågs vara tillräckligt utmanande att utföra samt intressant och lärorik. I följande spel kommer man köra en omgång poker mot datorn.
                Jag började med att skapa template-sidorna enligt projektets kravlista. Sedan skapade jag en ny kontroller (ProjectController.php) som skapar routes för samtliga projekt-sidor. Routen /proj tar sig till en landningssida som ger kortfattad information om projektet, 
                /proj/game tar sig till självaste kortspelet där man kan se två rader med fem kort samt en input för potten. Övre radens kort som är synliga tillhör spelaren och den nedre som är dolda tillhör datorn. Slutligen, finns routen /proj/about som ger mer information om projektet som dess syfte. Utöver routes för undersidorna finns även POST-routes för knapparna för de olika åtgärderna i spelet som byta kort, 
                sätt in pott och starta om spelet när man har spelat klart. Spelkorten som finns på planen är unicode-karaktärer som har stylats med CSS för att få rätt storlek samt färg. För att få fram ett specifikt tex för hjärter 7, så används klass-metoden "getCardRep" för kort-objektet som returnerar de avsedda unicode-karaktären för det angivna kortet.
            </p>
            <p>
                När användaren landar på /proj/game sidan så initieras spelobjektet "FiveCardPoker" från klassen i "Cards/FiveCardPoker.php" som har attributen "player" och "com" som motsvarar spelarens och datorns korthand. Övriga instansattribut är "deck" som lagrar kortleken för pågende spel, "turn" som lagrar antalet rundor som har passerats och slutligen "pot" som innehåller potten för spelets rundor. Innan spelaren kan gå vidare till det första bytet av kort så måste den placera en valfri summa där i början av spelet går det bra med summan 0. 
                När potten har satts in så kan spelaren börja byta kort. Man väljer bort korten genom att fylla i motsvarande checkbox placerad över kortet och trycker sedan på knappen "Byt" för att bekräfta valet. Byt-knappen är kopplad till POST-routen /proj/game/swap och vid kallelse skickas kortens plats/index (0-4 i ordning) som ska bytas ut genom ett tillhörande formulär för checkboxarna. 
                Formulär datat skickas som en inparameter för klassmetoden "swapCard" i "FiveCardPoker" som sedan kallar på klassmetoden "addAtIndex" i "CardHand" mot spelarens/datorns hand. Metoden "swapCard" börjar med att dra nya kort enligt antal som skall bytas ut och lagras som en lista i en variabel "card". Klassmetoden "addAtIndex" kallas tillsammans med "card" och index-listan för att sedans itereras igenom och ersätter det markerade korten med den nya omdefinering av värdet från index-adressen.
            </p>
            <p>
                För att göra spelet utmanande så har datorn en algoritm för att byta kort istället för att det sker på slumpen. Datorns algoritm utgörs av klassmetoden "comLogic" som innehåller en switch-satts för ett urval av olika kortranker; Triss, Ett par, Tvåpar, Högsta kort för att avögra vilka åtgärder som skall tas. Tex vid Ett par, Två par och Triss byts resterande kort som ej matchar, för Högsta kortet byts samtliga kort och om datorn skulle ha en högre kortrank än det som finns definerad i switch-sattsen så behåller datorn sin nuvarande hand tills spelet har passerat det sista bytet. 
                När värdet för antalet rundar har nått "4" så inaktiveras spel-knapparna och ett statusmeddelande om vem som vann samt med vilken hand träder fram. Detta görs via en if-satts som jämför värdet för nuvarande runda och om den skulle bli lika med 4 så sätts spel-variabel gameover till "true" och på så sätts inaktiveras inmatning och datorns kort avsjöljas. 
                Detta beror på att inmatningarna på template-sidan befinner sig inom en if-else satts som visas/döljs genom true/false från variablen "gameover" och "bet". För att avgöra vilken hand som vägger mest används klassmetoderna "compareHand" och "getPokerRank". "compareHand"-metoden har utfall för spelaren har en högre rank, datorn har högre rank och spelarna har en jämlik rank. 
                "getPokerRank"-metoden kallas i början av "compareHand" och har som syfte att avgöra vilken rank en hand tillhör. I början av "getPokerRank" initieras ett nytt objekt av klassen "CompareRank" som innehåller samtliga metoder som avgör om korthanden tillhör den ranken eller ej. "getPokerRank" fungerar likt en wrapper funktion där man kallar på samtliga metoder som avgör vilken rank korthanden tillhör och få utt ranken i text-form. 
                Jag valde att dela ut samtliga rankers vilkor i separata moduler för att göra det enklare att läsa och vilket i sitt led minskar den totala cyklomatiska kodkomplixten i "FiveCardPoker"-klassen. 
                Några exmpel för hur man kan lösa utt en handsrank programmatiskt som för Ettpar, Triss och Fyrpar kan man ta sig hjälp av de inbyggda funktioner array_count_values där den räknar ut frekvensen av värden i handen samt in_array för att avgör om den efterfrågade antalet finns med eller ej. Tex efterfrågas en frekvens på "4" om handen skall vara ett fyrpar eller "3" för Triss osv. 
                Värdet av "getPokerRank" i "compareRank"-metoden används mot en lista som finns globalt i "fivecardpoker"-klassen. 
                I listan finns samtliga ranker som nycklar och en tillhörande värde i relation till rankens position. På så sätt kan utföra jämförlesen i vilkoret för if-else sattsen. Slutligen returnerar "compareRank" vem som vann i ett textmeddelande som sedan försvidare till Projekt-kontroller och renderas på template-sidan. Om spelarna skulle få samma slutgitliga rank på korten finns ännu en metod, "compareRank" som fungerar likt "getPokerRank" fast där man även kontroller övriga korts värde och rank för att få fram vilken hand som är högre.
            </p>
            <p>
                Designändringarna för projeksidorna är relativt lika från de förgående kursmoment. Den största skillnaden är färgtemat som har fått en mer färgglad och varmare palette. Grundfärgerna fick jag insperation från hur ett klassiskt poker-bord brukar se ut i casinon där det finns grönt från bordsyttan, rött från marker samt guld för markörerna på spelplanen. Andra ändringar är av brödtexten där den nya fonten är Google fonts "Montserrat" som är en sans-serif font. 
                Jag ändrade även storleken och margin för fonten för header/footer en aning för att passa den nya fonttypen. Bakgrunden och färgerna för korten är däremot orörd då jag ansåg att färgerna ger redan en god kontrast.
            </p>
            <h3>Reflektion om projekten</h3>
            <p>
                Projektet har gått bra att genomföra även om det uppstod några komplikationer. Självaste utmaningen för projektet var att täcka alla möjligt utfall för hur en vinst/förlust kunde ske beroende korthänderna. En annan svårighet var att få ihop en godtagbar algoritm/svårighetsgrad för datorn så spelet blev någorlunda utmanande och icke-slumpad. Jag byggde successtivt upp samtliga utfall genom att testa samtliga rankar och se utmatning om vilken aktör som vann/förlorade. 
                När jag kom till testnings stadiet så upptäcktes nya fall där datorn/spelaren vann felaktigt. Detta bekräftade innebörden av att skriva testfall som berör samtliga utfall i en applikation då det är lätt hänt att överse fall inom implementations stadiet. 
                Jag gjorde datorns algoritm relativt enkel men anser ändå att vara tillräckligt utmanande. Jag definerade endast utfall för Högsta kort upp till Triss då man kan ej riskera att förlora ranken om man byter bort ett eller flera kort. Tex kan man med Triss byta två kort men ändå behålla sina tre matchande kort. Det blir en säker taktik som datorn kör med. Jag tycker projektet har varit både roligt och utmanande. Jag skulle definitvt säga att momentet kändes rimligt som kursens slutexaminerade arbete.
            </p>
            <h3>Tankar om kursen</h3>
            <p>
                Tycker kursen har varit bra och lärorik. Det ger en god introduktion för objektorienterad programmering inom sammanhanget av webben. Det moment som jag anser vara mest intressant var om tester och hur man kan tolka värdena för att optimera sin applikation. Det är lätt hänt att man slänger ihop en lösning som fungerar inom praktiken men kan i andra omständigheter bli jobbigt att underhålla och funktionlitet kanske ej fungerar om man exempelvist skulle bygga ut på en metod. 
                Med tanke på detta så har verktygen för att mätta kodkvalitet varit av stort intresse. Jag skulle sammanfatta kursens betyg som en 7:a och kan rekommendera kursen för den som vill komma igång med objektorienterad programmering för webbapplikation.
            </p>
        </section>
    </article>
    
{% endblock %}