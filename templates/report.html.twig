{% extends "base.html.twig" %}

{% block title %}Redovisning{% endblock %}

{% block body %}
    <article>
        <header>
            <h1>Redovisning av kursmoment i mvc</h1>
        </header>
        <section>
            <h2 id="kmom01">Kmom01</h2>
            <p>Konceptet om objektorientering är ej något nytt för mig, har använt mig av det i tidigare dbwebb-kurser, både i Python och PHP från den förra mvc-kursen. Skillnaden mellan dessa språk ligger i syntaxen över hur en klass initieras och kan då utan svårigheter pendla mellan dessa språk.</p>
            <p>
                Än så länge har vi skapat klasser för controller som hanterar de olika sidorna utan någon konstruktor-metod, vilket är princip nästan som att programmera i den funktionell paradigmen. 
                Den enda objekt-specificerade syntaxen för utom klass-deklarationen var instansvariabeln $this som representerar en instans av en klass. När man skapar klasser börjar man med självaste deklarationen, sedan bör man skapa en konstruktor för att lagra attribut för varje enskild instans. Slutligen kan man skapa klass-metoder som arbetar direkt med objekten och dess värden. 
            </p>
            <p>
                För att lägga till en undersida i symfony börjar man med att skapa en controller-klass i Controller-mappen om det inte redan finns,  sedan lägger man till klass-metoder som representerar varje enskild route/sida. För att koppla klassmetoden till GET-förfrågan så lägger man till en kommentar ovanför med funktions-anrop till Route med sökvägen och dess namn. 
                I varje klass-metod bör man åtminstone returnera instansvariabeln med render-funktionen med inparametern för motsvarande twig-fil. Innehållet för samtliga sidor finns i de olika twig-filerna i templates-mappen. I mappen finns en base-twig som innehåller head för samtliga sidorna som innehåller bland annat navbaren, länk till CSS-filen samt uppsättning av karaktärer (UTF-8). Övriga twig-filer ärver base klassen och bygger vidare på body-sektionen. Övrigt innehållet utöver text som bilder och CSS finns tillgänglig public-mappen med varsin mapp. 
            </p>
            <p>
                Jag kikade snabbt över artikeln och alla dess underrubriker, fann sektionen för säkerhet intressant då det är viktigt att kunna rusta upp sina webbapplikationer för cyberattacker/intrång, vilket blir ännu viktigare i framtiden pga den växande digitaliseringen där olika komponenter i samhället är helt beroende av ett digitalt-system för att fungera. 
            </p>
            <p>
                I detta kursmoment har jag lärt mig grunderna för PHP-ramverket Symfony vilket täcker skapandet av Controller, undersidor i twig, samt dess fil-struktur. Dock inga nya kunskaper gällande objektorientering  än så länge då allt kändes bekant. 
            </p>

            <h2 id="kmom02">Kmom02</h2>
            <p>
                Arv inom objektorientering är när en klass ärver klassmetoder och attribut från en föräldrar klass. Ett exempel skulle kunna vara en bass klass för djur där man väljer att skapa en barnklass för attribut som gäller för hundar. Man bygger helt enkelt vidare på bass klassen med nya metoder och attribut som gäller för specifika ändamål utan att påverka självaste föräldrar klassen. 
                En kompositions relation inom objektorientering menar man en relation som ena klassen är beroende av för att skapa dessa egna objekt. 
                Ett exempel skulle kunna vara ett rum i huset där ett rum kan inte existera utan ett hus, men ett hus behöver inte inneha några rum för att existera. En interface inom PHP-sammanhang är ett sätt att definiera klass metoder utan att direkt implementation. Interface är mer ett sätt för att spediera metoder som bör förekomma för klassen. 
                Slutligen traits är ett sätt att underlätta/undvika multipla ärv av klasser, då PHP saknar stöd för detta samt är det en bättre vanna att inte skapa klasser med multipla ärv. Traits är en uppsättning av klassmetoder som en eller flera klasser kan används sig utav utan att förbinda ett parent-child förhållande.
            </p>
            <p>
            Jag började med att skapa det grundläggande klasserna; Card och Deck med godtyckliga attributvärden och klassmetoder. Sedan skapade jag en ny controller för samtliga card-klasser för att testa initiering av objekt för att se om det fungerar som tänkt. Nästa steg var att skapa routes och twig-templates enligt kravspecen. Jag valde här näst en metod för att representera de olika spelkorten där min lösning var ett skapa en CardGraphic klass bestående av unicode-karaktärer och ärver Card klassen. 
            CardGraphics returnera motsvarande värde genom dess rang och färg motsvarare en specifik nyckel för unicode-arrayen som den anroppar och returneras unicode-värdet. Slutligen vissas samtliga spelkort genom en for-loop där CardGraphic metoden "getCardRep" anroppas. 
            Jag känner mig nöjd än så länge. En förbättringsförslag skulle möjligtvis var att dela upp klassmetoder från Deck till CardHand som relaterar till draw-funktionerna. En annan förbättring skulle kunna vara dokumentering/kommentera koden för att underlätta läsligheten för andra och mig själv.
            </p>
            <p>
                Än så länge känns allt tydligt och klart med Symfony och MVC-konceptet. Jag har arbetat i liknande utvecklingsmiljöer sedan tidigare.
            </p>
            <p>
                Min TIL handlar om det introducerade PHP-koncepten som Interface och Traits som verkar var bra ersättningar för ärv-relationer, vilket kan komma till nytta när man vill använda en uppsättning metoder utan att skapa ett beroende/förhållande med en klass.
            </p>

            <h2 id="kmom03">Kmom03</h2>
            <p>
                Fördelen med att modellera ett projekt innan man börjar med implementationer är att man kan överföra tanker och idéer från huvudet till pappret vilket medför att man kan få en checklista att boka av genom utvecklingsstadiet, vilket medför en smidigare utvecklingsprocess. 
                För mig får jag även en form av validation om tankarna finns rakt framför mig i fysiskt form och kan då enklare bryta ned dem för att se om det håller i "verkligheten". En annan fördel med flödesdiagram och pseudokod skulle vara för att redovisa sina tankar inom ex ett utvecklingsteam där det är mer eller mindre obligatorisk då övriga skall kunna förstå samt validera dina tankar för projektet.
            </p>
            <p>
                Jag började med att skapa klassen för spel-kontroller. Nästa steg var att skapa de templates för sidorna enligt kravspecen. Sedan implementerad jag resterade metoder stegvist och validerade utmatningen av objekten med hjälp av "var_dump".  När jag kommit halvvägs genom projektet noterade jag att kontroller började bli en aning  massiv och beslutade då enligt uppmaningen från kravspecen att refaktoriserar koden med hjälp av en separat klass för spelet och dess metoder/funktionalitet. 
                I slutändan sparade jag minskade jag kontroller med ca 30 rader kod. För att få motsvarande poäng för samtliga spelkort modifierade jag Card-klassen med ett nytt instansattribut "point" och en get-metod i HandCard-klassen (representerar spelarnas kort i handen) för att summera spelarnas kortsumma för varje runda. Jag är överlag nöjd med mitt kortspel när det kommer till funktionaliteten. Däremot kan gränssnittet poleras då den är för stunden relativt simpel/primitiv då jag har inte lagt en större del kring stylingen.
            </p>
            <p>
                Jag har inte haft några svårigheter att komma igång med Symfony då ramverket skiljer sig inte speciellt mycket från övriga ramverk som jag har jobbat med. Tycker konceptet med kontroller och templates är tydliga.
            </p>
            <p>
                Min TIL är hur självaste utvecklingsprocessen för ett mindre projekt inom Symfony kan ske.
            </p>

            <h2 id="kmom04">Kmom04</h2>
            <p>
                Jag har tidigare jobbat med enhetstester i andra programmeringsspråk som Python och JavaScript och noterade inga speciella skillnader med att skriva tester i PHPUnit. När det kom till att testa model-klasserna för min mvc-report gick det bra och behövde endast göra minimala ändringar i koden för att få den mer testbar. Ex i Game21-klassen vill jag testa en metod som avgör vem som vinner beroende på vilka kort i handen motståndaren har. 
                Eftersom korten tilldelas slumpmässigt behöver jag på något sätt skapa en lösning där man kan definiera en korthand. I mitt fall valde jag att skapa nya setters för vardera spelare där man kan skapa en korthand med specifika kort. Ett annan sätt att lösa ovanstående problem skulle kunna vara att mocka random-funktionen i metoden som tilldelar kort.
            </p>
            <p>
                Tycker jag lyckades väl med kodtäckningen av modell-klasserna där jag fick en täckning på hela 100% för totalt 5st klasser.
            </p>
            <p>
                Jag upplevde min kod för grundklasserna att var mer eller mindre testbara. Det enda klassen jag blev tvungen att fixa till var klassen som redogör en omgång av kortspelet, mer specifikt för att testa de olika sätten ett spel kan avslutas. Då poäng för spelets motståndare sker på slumpen, blir det då svårt att skriva testfall där den ger olika värden för varje anrop. Min lösning var att skapa setter-metoder för att ange det önskvärda värdet som triggar igång en av utfallen för ett spelets summering.
            </p>
            <p>
                Jag valde att addera klass-metoder istället för att skriva om existerande kod då jag vill ej riskera att något går sönder vid refaktoriseringen. De metoder jag la till var klass-setters vilket jag anser vara "lätta" på resurserna och tar upp få kodrader, vilket gjorde att jag kunde implementera dem utan dåligt samvete.
            </p>
            <p>
                Testbar kod är definitivt något som jag ser som en god kodkaraktäristik då det underlättar utförandet vid teststadiet. Tester är i sin tur ett sätt att garantera en viss kvalité av funktionalitet för programmet och för att säkerställa att metoderna har ett önskvärd beteende.
            </p>
            <p>
                Min TIL för detta kmom var hur man kan generera ett dokument för kodkommentarer med phpdoc och en täckningsrapport via phpunit.
            </p>

            <h2 id="kmom05">Kmom05</h2>
            <p>
                Det gick bra att komma igång med Doctrine för Symfony. Guiden förklarade stegvist för hur komponenterna fungerar samt gav exempelkod som underlättade vid den ursprungliga implementationen. Mina tankar kring ORM och Symfony var hur väl dessa verktyg var implementerad för att samarbeta med varandra. Tex kan man smidigt auto-generera en databas tabell utan att skriva en enda sql-lina. En annan egenskap med ORM/Symfony var dess medföljda script för versionshanteringar av tabeller.
            </p>
            <p>
                Mitt gränssnitt för webbappen kännetecknas av en simpel design med färger av högkontrast. jag valde att grunda mitt färgtema utifrån användargränssnitt från skrivbordsmiljöer 80-90-talet då dessa har god kontrast samt rent utav smaksak. Självaste navigationen samt aktivering av funktioner för sidan (ex lägga till, radera eller redigera) görs via länkar som tar användaren till en separat sida med formulär.
            </p>
            <p>
                Det gick bra med att komma igång med CRUD inom ORM. Jag upplevde ingen större skillnad än en traditionell relationsdatabas mer än att samtliga funktioner och rader sker via klass-metoder och instanser. För att lägga till, uppdatera eller radera en rad i tabellen görs via ett "ManagerRegister"-objekt. För att ex addera eller uppdatera användes klassmetoden "persist" som talar om att ett objekt är på väg in i databasen, sedan anges objektets attributer med set. För att spara ned ändringarna gör man en anrop till "flush"-klassmetoden.  Helt enkelt skiljer sig ORM med att man jobbar mot objekt där traditionella databaser används SQL-stränger för att kommunicera.
            </p>
            <p>
                ORM är ett alternativt sätt att processers data från databas tabeller där istället för SQL används objekt för att representera olika tabellrader. En fördel med ORM är att man skapa egna funktioner som kommunicerar med databasen inom valfritt programmeringsspråk utan en enda rad SQL.
            </p>
            <p>
                Jag har lärt mig en ny databas koncept där man jobbar med objekt istället för SQL samt hur man använder denna teknik inom ett Symfony-projekt.
            </p>

            <h2 id="kmom06">Kmom06</h2>
            <p>
                Jag tycker PHPMetrics är ett bra verktyg även om det kunde vara överväldigade i början med alla dess mätvärden och hur man skall tolka dem. Det var en del enheter jag hade svårigheter över vad det ger uttryck för. Det jag gillade med PHPMetrics var några grafer, 
                bland annat klass kod komplexiteten  som redovisades som en spiral cirklar i olika färger för graden av komplexiteten. Det fanns även en graf där man kunde se kopplingar för samtliga klasser, vilket gav en tydliga överblick över klassrelationerna. 
            </p>
            <p>
                Det gick bra att komma igång med Scrutinizer, det fungerade felfritt direkt efter kopplingen. Jag tycker Scrutinizer har ett tydligt och simpelt gränssnitt vid presentation av data.  Tycker Badges är ett bra sätt att presentera projektets kodkvalitet. 
                Det verkar smidigt att ha klickbara badges för att i detalj se det olika kvalitetsaspekterna för projektet i fråga. Efter den första kopplingen fick jag en kodtäckning på 19% som jag fick sedan upp till 46% efter tillagt tester för olika controllers. 
            </p>
            <p>
                Kodkvaliten enligt mig är en viktigt grund för att projekt skall vara underhållbar och prestera bra. En tydlig kod anser jag ger även projektet ett gott första intryck för utomstående utvecklare och en större chans till engagement vid tex ett OpenSource projekt vilket kan gynna projektet i längden om flera utvecklare bidrar till dess utveckling. 
                Badges behöver inte alltid garantera att projektet är välskriven då automatiserade verktyg som Scrutinizer bedömer projektet utifrån en algoritm och kan därefter ha svårigheter att bedöma projektets funktionalitet i sin helhet och kan då ge en felaktig bedömning. 
                Enligt mig så bör man granska koden manuellt och försöka att se koden för projektet som en utomstående då vissa implementationer som är självklart för sig själv är inte alltid det för andra. 
            </p>
            <p>
                Min TIL handlar om hur man kan jobba med automatiserade kodvalidatorer för att förbättra kvalitén för sitt projekt. Samt att det finns ett brett spektrum av aspekter som tillsammans bidrar till det huvudsakliga kodkvaliten för ett projekt.
            </p>
        </section>
    </article>
    
{% endblock %}